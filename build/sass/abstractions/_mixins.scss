@mixin bg-image($page, $location, $size) {
    background-image: url('../assets/img/bg/bg-#{$page}-#{$location}.jpg');
    @include background-size($size);
}

@mixin bg-image-files($name: bg-image, $path: default, $size: cover, $pos: center) {
    background-image: url('/sites/default/files/carousel/#{$path}/bg-#{$name}.jpg');
    @include background-size($size);
    background-position:$pos;
}

@mixin backgroundImage($image: default, $ext: jpg, $size: cover, $pos: center) {
    background-image: url('../assets/bg/bg-#{$image}.#{$ext}');
    @include background-size($size);
    background-position:$pos;
}
/* Padding All
/* @include padding($padding: 10px);
/* ----------------------------------------------------------------- */

@mixin padding($padding: 10px) {
  padding-bottom: $padding;
  padding-left: $padding;
  padding-right: $padding;
  padding-top: $padding;
}

/* Transistion
/* @include TransistionEffect($delay: 0s, $duration: 0.25s, $property: all);
/* ----------------------------------------------------------------- */

@mixin TransistionEffect($delay: 0s, $duration: 0.25s, $property: all) {
    @include transition-delay($delay);
    @include transition-duration($duration);
    @include transition-property($property);
}

// Button Styles
// ===================================================================================================== +

$calibrate-amount: 120;
$calibrate-amount-secondary: 10;
@mixin magicButton($buttonBackground) {
    $buttonBackground1: scale-saturation($buttonBackground, $calibrate-amount);
    $buttonBackground2: scale-saturation($buttonBackground, $calibrate-amount-secondary);
    background-color: $buttonBackground;
    background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgi…pZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JhZCkiIC8+PC9zdmc+IA=='),$buttonBackground;
    background: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, $buttonBackground1),color-stop(100%, $buttonBackground2)),$buttonBackground;
    background: -moz-linear-gradient($buttonBackground1,$buttonBackground2),$buttonBackground;
    background: -webkit-linear-gradient($buttonBackground1,$buttonBackground2),$buttonBackground;
    background: linear-gradient($buttonBackground1,$buttonBackground2),$buttonBackground;
    @include box-shadow(inset rgba(255,255,255,0.5) 0 1.5px 0,rgba(0,0,0,0.3) 0 1px 2px);
    @include border-radius(4.5px);

    &:hover {
      @include box-shadow(inset rgba(255,255,255,0.3) 0 1px 0,rgba(0,0,0,0.2) 0 1px 2px,$buttonBackground 0 1px 20px,rgba(0,0,0,0.6) 0 1px 2px,$buttonBackground 0 1px 2px)
    }
  }


// User Interface Background Image
// Shorthand Reference: @include uiImage($image: icon--default, $ext: png, $size: 25px 25px);
// ===================================================================================================== +
@mixin uiImage($image: default, $ext: png, $size: 25px 25px, $pos: 5px center) {
    background-image: url('../assets/ui/bg-#{$image}.#{$ext}');
    @include background-size($size);
    background-position:$pos;
    background-repeat: no-repeat;
}

@mixin container() {
  margin: 0 auto;
  width: $breakpointExtraSmall;
  @include breakpoint($breakpointSmall) {
    width: $breakpointMedium;
  }
  @include breakpoint($breakpointMedium) {
    width: $breakpointLarge;
  }
  @include breakpoint($breakpointLarge) {
    width: $breakpointExtraLarge;
  }
}

@mixin container-fluid() {
  margin: 0 auto;
  max-width: 1420px;
  width: 90%;
  @include breakpoint($breakpointExtraSmall) {
    width: $breakpointMedium;
  }
  @include breakpoint($breakpointSmall) {
    width: $breakpointMedium;
  }
  @include breakpoint($breakpointMedium) {
    width: $breakpointLarge;
  }
  @include breakpoint($breakpointLarge) {
    max-width: $breakpointExtraLarge;
  }
}

@mixin container-full() {
  margin: 0 auto;
  max-width: 100%;
  padding: 0px;
  padding-left: 0px;
  padding-right: 0px;
  width: 100%;
}



@mixin backgroundGradient($colorFirst: #FFF, $colorSecond: #FFF, $colorThird: #FFF) {
  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgi…pZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JhZCkiIC8+PC9zdmc+IA=='),$colorThird;
  background: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, $colorFirst),color-stop(100%, $colorSecond)),$colorThird;
  background: -moz-linear-gradient($colorFirst,$colorSecond),$colorThird;
  background: -webkit-linear-gradient($colorFirst,$colorSecond),$colorThird;
  background: linear-gradient($colorFirst,$colorSecond),$colorThird;
}

@mixin linear-gradient($direction, $color-stops...) {
  background: nth(nth($color-stops, 1), 1);
  background: -webkit-linear-gradient(legacy-direction($direction), $color-stops);
  background: linear-gradient($direction, $color-stops);
}

@mixin horizontal-gradient($start: #000, $stop: #FFF) {
    // background: ($start + $stop) / 2; <= We are using RGBA values for the time being.
    background: -webkit-gradient(linear, left, right, from($start), to($stop)) !important;
    background: -moz-linear-gradient(center top, $start 0%, $stop 100%) !important;
    background: -moz-gradient(center top, $start 0%, $stop 100%) !important;
}

// Live: @include vertical-gradient($start: #000, $stop: #FFF);
@mixin vertical-gradient($start: #000, $stop: #FFF) {
    // background: ($start + $stop) / 2; <= We are using RGBA values for the time being.
    background: -webkit-gradient(linear, left top, left bottom, from($start), to($stop)) !important;
    background: -moz-linear-gradient(center top, $start 0%, $stop 100%) !important;
    background: -moz-gradient(center top, $start 0%, $stop 100%) !important;
}

@mixin vertical-gradient-with-image($image, $start: #000, $stop: #FFF) {
    background: ($start + $stop) / 2 $image;
    background: $image, -webkit-gradient(linear, left top, left bottom, from($start), to($stop));
    background: $image, -moz-linear-gradient(center top, $start 0%, $stop 100%);
    background: $image, -moz-gradient(center top, $start 0%, $stop 100%);
}


@mixin opacity($op) {
    -khtml-opacity: $op;
    -moz-opacity: $op;
    opacity: $op;
}




//------------------------------------
//  MIXINS
//------------------------------------

//
// Uses `calculate-rem()` to calculate rem font-size and px
// fallback. line-height is calculated with `calculate-line-height()`
// but passing `false` will prevent that.
//
// Parameters:
//  $font-size: the font size (in pixels) to be converted to rem
//  $rem-sizing: if you want to convert the font-size to rem or not (default is true)
//  $line-height: set to false if you wish not to output a calculated line-height (defalt is true)
//
// Example:
//  `@include font-size(24px);`
//
//
// Big thanks to inuitcss for inspiration behind this
// (https://github.com/csswizardry/inuit.css/blob/master/generic/_mixins.scss)
@mixin font-size($font-size, $rem-sizing: true, $line-height: true) {
  font-size: $font-size;

  @if $rem-sizing == true {
    font-size: calculate-rem($font-size);
  }

  @if $line-height == true {
    line-height: calculate-line-height($font-size);
  }
}


//
// Proper vendor prefixes are created by passing
// a property, property value, and browser
// vendor (webkit, moz, ms, o, etc).
//
// Parameters:
//  $property: what CSS property to generate vendor prefixes for
//  $value: the value of what was defined in `$property`
//  $vendors: what vendor prefixes to generate (default is none)
//
// Example:
//  `@include vendor(border-radius, 4px, webkit moz ms)`
//
//
@mixin vendor($property, $value, $vendors: "") {
  @each $vendor in $vendors {
    @if $vendor != "" {
      -#{$vendor}-#{$property}: $value;
    }
  }

  #{$property}: $value;
}


//
// Loops through all of the values in the `$breakpoints`
// map and outputs conditional statements used to generate
// media query code.
//
// When calling the mixin, if the parameter matches a key
// from the `breakpoints` map, a media query is output with
// that key's value. If an explicit value is set (ex: 360px)
// then a media query is output with that value.
//
// Parameters:
//  $point: the breakpoint value for the media query output
//  $min-max: set whether `min-width` or `max-width` is used (default is `min-width`)
//
// Example:
//  `@include breakpoint(extra-small) { ... }`
//
//  `@include breakpoint(360px) { ... }`
//
//
@mixin breakpoint($point, $use-max-width: false) {
  $min-max: "min";

  @if $use-max-width == true {
    $min-max: "max";
  }

  @if type-of($point) == string {
    @each $breakpoint-name, $breakpoint-value in $breakpoint-map {
      @if $point == $breakpoint-name {
        @media (#{$min-max}-width: $breakpoint-value) {
          @content;
        }
      }
    }
  } @else {
    @media (#{$min-max}-width: $point) {
      @content;
    }
  }
}


//
// Generates property media queries for any CSS property,
// value, and set of breakpoints. Allows you to easily change
// property values based a set of breakpoints.
//
// Parameters:
//  $properties: what CSS property to output inside of the media queries (can have multiple)
//  $values: the value for each property (can have multiple)
//  $responsive-values: what breakpoints to generate media queries for
//  $use-available-mixins: whether or not to use mixin outputs for properties like `font-size` or `line-height` (default is true)
//
// Example:
//  @include responsive("font-size", 11px,
//    (
//      "small" : 12px,
//        450px : 13px,
//       1100px : 14px,
//      "large" : 15px,
//       1600px : 16px,
//    )
//  );
//
//
@mixin responsive($properties, $values, $responsive-values, $use-available-mixins: true) {
  @each $property in $properties {
    @if $property == "font-size" and $use-available-mixins == true {
      #{$property}: $values;
      #{$property}: ($values / $base-font-size) * 1rem;
    } @else if $property == "line-height" and $use-available-mixins == true {
      #{$property}: ceil($values / $base-line-height) * ($base-line-height / $values);
    } @else {
      #{$property}: $values;
    }
  }

  @each $breakpoint, $value in $responsive-values {
    @if type-of($breakpoint) == string {
      @if(map-has-key($breakpoint-map, $breakpoint)) {
        $breakpoint: map-get($breakpoint-map, $breakpoint);
      } @else {
        $breakpoint: "null";
        @warn "Couldn't find breakpoint: " + $breakpoint;
      }
    }

    @if $breakpoint != "null" {
      @media (min-width: $breakpoint) {
        @each $property in $properties {
          @if $property == "font-size" and $use-available-mixins == true {
            #{$property}: #{$value};
            #{$property}: ($value / $base-font-size) * 1rem;
          } @else if $property == "line-height" and $use-available-mixins == true {
            #{$property}: ceil($value / $base-line-height) * ($base-line-height / $value);
          } @else {
            #{$property}: #{$value};
          }
        }
      }
    }
  }
}

// The responsiveFull mixin is different than the "responsive" mixin, because it handles max-width.
// The only problem is the "if (map-has-key...." function was causing variable overwrite issues.
// Which means debugging is non-existent and we assume you are using the 
// $breakpoint-map and $breakpoint-map-max in tandem and know what you are doing.

//@mixin tablet {
//  @media (min-width: #{$tablet-width}) and (max-width: #{$desktop-width - 1px}) {
//    @content;
//  }
//}

@mixin responsiveMinMax($properties, $values, $responsive-values, $use-available-mixins: true, $use-max-query: true) {
  @each $property in $properties {
    @if $property == "font-size" and $use-available-mixins == true {
      #{$property}: $values;
      #{$property}: ($values / $base-font-size) * 1rem;
    } @else if $property == "line-height" and $use-available-mixins == true {
      #{$property}: ceil($values / $base-line-height) * ($base-line-height / $values);
    } @else {
      #{$property}: $values;
    }
  }// End each $property
  
  @each $breakpoint, $value in $responsive-values {
    @if $breakpoint != "null" {

    @if $use-max-query == true {
      $breakpointMin: map-get($breakpoint-map, $breakpoint);
      $breakpointMax: map-get($breakpoint-map-max, $breakpoint);
      @media (min-width: #{$breakpointMin}) and (max-width: #{$breakpointMax - 0.01em}) {
        @each $property in $properties {
          @if $property == "font-size" and $use-available-mixins == true {
            #{$property}: #{$value};
            #{$property}: ($value / $base-font-size) * 1rem;
          } @else if $property == "line-height" and $use-available-mixins == true {
            #{$property}: ceil($value / $base-line-height) * ($base-line-height / $value);
          } @else {
            #{$property}: #{$value};
          }
        }
      }
    }

    @if $use-max-query == false {
      $breakpointMin: map-get($breakpoint-map, $breakpoint);
      @media (min-width: #{$breakpointMin}){
        @each $property in $properties {
          @if $property == "font-size" and $use-available-mixins == true {
            #{$property}: #{$value};
            #{$property}: ($value / $base-font-size) * 1rem;
          } @else if $property == "line-height" and $use-available-mixins == true {
            #{$property}: ceil($value / $base-line-height) * ($base-line-height / $value);
          } @else {
            #{$property}: #{$value};
          }
        }
      }
    }

    } // End if $breakpoint
  } // End each $breakpoint
} // End @mixin responsiveFull


//
// Generates CSS to wrap semantic columns
// in a row.
//
// Example:
//  `@include row()`
//
//
@mixin row() {
  width: 100%;

  &:after {
    clear: both;
    content: " ";
    display: table;
  }
}


//
// Generates CSS for semantic columns.
//
// Parameters:
//   $column: the number of this particular column (determines width)
//   $number-columns: number of columns in the row (default is `$column-number`)
//   $first-column: set to `true` if it's the first column in a row (default is false)
//   $use-gutters: set to `true` if you want column gutters (default is false)
//   $gutter-value: percentage value of the gutters to be applied (default is `$gutters` variable)
//
// Example:
//  `@include column(16, 4, false, true, 4)`
//
//
@mixin column($column, $number-columns: $column-number, $first-column: false, $use-gutters: false, $gutter-value: strip-units($gutters)) {
  @include vendor(background-clip, padding-box, webkit);

  @include breakpoint(small) {
    @if $use-gutters == true {
      $gutter-size: percentage($gutter-value) * 0.01;
      $width-of-column: (100% - $gutter-size * ($number-columns - 1)) / $number-columns;

      float: left;
      @if $first-column == false {
        margin-left: $gutter-size;
      }
      width: $width-of-column * $column + $gutter-size * ($column - 1);
    } @else {
      float: left;
      width: percentage(100 / $number-columns * $column) * .01;
    }
  }
}


//
// Generates CSS for pushing a semantic column left or right.
//
// Parameters:
//   $option: set to `push` or `pull` to generate proper styles
//   $column: the column number
//   $number-columns: the number of columns in the row (default is $column-number)
//   $use-gutters: set to `true` if your column has gutters (default is false)
//   $gutter-value: percentage value of the gutters to be applied (default is `$gutters` variable)
//
// Example:
//  `@include push-pull(push, 4, 16, true)`
//
//
@mixin push-pull($option, $column, $number-columns: $column-number, $use-gutters: false, $gutter-value: strip-units($gutters)) {
  $property: "";

  @if $option == "push" {
    $property: "left";
  } @else {
    $property: "right";
  }

  @if $use-gutters == true {
    #{$property}: 100% / $number-columns * $column - $gutter-value;
  } @else {
    #{$property}: 100% / $number-columns * $column;
  }
}


//
// Generates CSS that will clear both left
// and right floats.
//
// Example:
//  `@include clearfix()`
//
//
@mixin clearfix() {
  & {
    &:after{
     content: "";
     display: table;
     clear: both;
    }
  }
}


//
// Create variable-number grid columns given the value
// for variable `$column-number`.
//
// NOTE:
//   This is a setup mixin for the Concise grid. If you
//   wish to set up a grid, please use the `row()` and
//   `column()` mixins.
//
@mixin grid-setup($number: $column-number) {
  @for $i from 1 through $number {
    $column-width-gutters: (100% - $gutters * ($number - 1)) / $number;

    .#{$column-prefix + $i} {
      width: 100% / $number * $i;

      .gutters & {
        width: $column-width-gutters * $i + $gutters * ($i - 1);
      }
    }
  }
}


//
// Create `.push-` and `.pull-` classes given
// the value for variabls `$option` and
// `$column-number`.
//
// NOTE:
//   This is a setup mixin for the push and pull
//   functionality in the Concise grid. If you wish
//   to use that functionality, please use the
//   `push-pull()` mixin.
//
@mixin push-pull-setup($option, $number: $column-number) {
  $property: "";

  @if $option == "push" {
    $property: "left";
  } @else {
    $property: "right";
  }

  @for $i from 1 to $number {
    .#{$option}-#{$i} {
      #{$property}: 100% / $number * $i;

      .gutters & {
        #{$property}: 100% / $number * $i - $gutters;
      }
    }
  }
}
